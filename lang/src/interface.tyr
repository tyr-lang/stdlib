/**
 * The type of a class interface, i.e. a regular interface.
 *
 * @todo typeIDs and cast functions too
 *
 * @note Runtime type checking against interface types is performed using a
 *       linked hash map and is therefore linear in the number of interfaces
 *       implemented by the target object.
 *
 * @note Runtime representation of interfaces is pretty useless without generic
 *       type paramaters. This will likely be implemented in 0.7 or 0.9.
 *
 * @note it is not possible for Interface to have (object) def or class members
 *
 * @author Timm Felden
 */
class Interface <: Type {

  /**
   * Interface initialization is performed by the back-end globally.
   * The initialization of Interface values happens even before evaluation of
   * global initialization.
   */
  private new <: native;
}

/* TODO 0.7
class ITypes {
  /**
   * Initiallization is performed while Classes are constructed.
   * /
  private new <: native;

  val implemenets : Array[Interface]
  val next : ITypes

  type def contains(this : ITypes, t : Interface) {
    if(null == this) false
    else implements.exists i : Interface do (t == i) || next.contains(t)
  }
}
*/

/**
 * Abstract layout is 
 * record ITable { ITable* super; int size; (ITableKey, Offset)[0] entries }
 *
 * Concrete layout is
 * record _TIT:*** { ITable info; (ITableKey, Offset)[size] }
 *
 * @note instances of this type can only be created by sleipnir
 *
 * @author Timm Felden
 */
type ITable <: native {
  val super : ITable;
  
  val size : container.size_t;
  
  var entries : container.FlatSizedArray[ITableEntry, 0L];
  
  /**
   * the ITable access algorithm is basically:
   *
   * @note it requires that the front-end has proven that the itable will
   *       contain the requested key
   *
   * @note the GEP instruction usually used to perform the access is replaced by
   *       calling get at runtime, casting this to i8*, performing GEP with the
   *       result, casting that result back to the expected type and continue
   *       afterwards as if a static access had happened
   */
  type def get(it : ITable, key : int) : int {
    // note: no null checking is required, because the key is always found in a 
    // type-correct program
    var i = it.size
    while (0L != i) {
      --i
      var e = it.entries(i)
      if(key == e.ITableKey)
        return e.offset
    }
    return get(it.super, key)
  }
}

/* created by sleipnir */
type ITableEntry <: native {
  val ITableKey : int;
  val offset : int;
}
