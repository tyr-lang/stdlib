/**
 * A string is a sequence of human readable characters. A string shall behave
 * like an Array[byte] of utf-8-endocding of these characters.
 *
 * @note eq shall be the identity on the bytes in this string
 *
 * @note hashed shall return the xor-folded projection of the bytes in this
 *       string onto hashCode. I.e. if hashCode were 8 bytes long, every 8 bytes
 *       shall be converted to a hashCode and all hashCodes shall be xored.
 */
public class String <: Object/* TODO blocker 0.7
                , InheritedHash[String]
                */, abstract {

  /**
   * @return the number of bytes required to represent this string in UTF-8.
   */
  public def size : container.size_t;

  /**
   * @return exactly size bytes representing this string as UTF-8 byte sequence.
   *
   * @note if the string is zero-terminated and the zero is considered part of
   *       the string, it has to be taken into account when returning size
   *
   * @note Generally speaking, it is legal to return zero bytes in the middle of
   *       a string. Nonetheless, some subclasses will not be able to do that.
   */
  public def bytes : container.Iterator[byte];
}

/**
 * Literal strings that can be evaluated at CT. Be aware of null being a valid
 * StringLiteral!
 */
public class StringLiteral <: String, noVar, mem.eternal {

  private new <: native;
  
  public val length : container.size_t;

  private val data : container.FlatArray[byte];

  public def size : container.size_t = length;
  
  public def bytes : container.Iterator[byte] =
    new container.FlatArrayIterator[byte](data, length);

  /**
   * print the string to std out
   *
   * @note this operator will be removed eventually
   */
  public type def !!(v : StringLiteral) : void 
                  <: native, operator.postfix, operator.precedence[10];
  
  test "show" {
    "show!\n"!!
  }
}
