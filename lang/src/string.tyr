/**
 * A string is a sequence of human readable characters. A string shall behave
 * like an Array[byte] of utf-8-endocding of these characters.
 *
 * @note eq shall be the identity on the bytes in this string
 *
 * @note hashed shall return the xor-folded projection of the bytes in this
 *       string onto hashCode. I.e. if hashCode were 8 bytes long, every 8 bytes
 *       shall be converted to a hashCode and all hashCodes shall be xored.
 */
public class String <: Object/* TODO blocker 0.7
                , InheritedHash[String]
                */, abstract {

  /**
   * @return the number of bytes required to represent this string in UTF-8.
   */
  public def size : container.size_t;

  /**
   * @return exactly size bytes representing this string as UTF-8 byte sequence.
   *
   * @note if the string is zero-terminated and the zero is considered part of
   *       the string, it has to be taken into account when returning size
   *
   * @note Generally speaking, it is legal to return zero bytes in the middle of
   *       a string. Nonetheless, some subclasses will not be able to do that.
   */
  public def bytes : container.Iterator[byte];
}

/**
 * Two strings are equal if
 * - they are identical
 * - they have the same length and all bytes are the same
 */
public type StringEQR <: EQR[String] {

  override
  type def equals (left : String, right : String) : bool
    = left == right || (
      left.size() == right.size() && {
        var rs = right.bytes()
        var ls = left.bytes();
        val r = ls.forall c do(c == rs.next())
        delete rs
        delete ls
        r
      }
    )
}

/**
 * Literal strings that can be evaluated at CT. Be aware of null being a valid
 * StringLiteral!
 */
public class StringLiteral <: String, noVar, mem.eternal {

  private new <: native;

  public val length : container.size_t;

  /**
   * @note allow tyr.io to access string literal data
   */
  private[tyr] val data : container.FlatArray[byte];

  public def size : container.size_t = length;

  public def bytes : container.Iterator[byte] =
    new container.FlatArrayIterator[byte](data, length);

  /**
   * print the string to std out
   *
   * @note this operator will be removed eventually; likely after adding varargs
   */
  public type def !!(v : StringLiteral) : void 
                  <: native, operator.postfix, operator.precedence[10];
  
  test "show" {
    "show!\n"!!
  }
}

/**
 * A String that is backed by a contiguous bytes of at least length bytes. It is
 * not null terminated. This is basically an abstraction that allows efficient
 * read-processing of strings.
 *
 * TODO This view should use read-only data once available
 */
public class SolidStringView <: String {

  public new (
    length := length : container.size_t,
    data := data : mem.HeapPointer[byte]
  );
  public delete;

  public val length : container.size_t;

  /**
   * @note allow tyr.io to access string literal data
   */
  public val data : mem.HeapPointer[byte];

  public def size : container.size_t = length;

  public def bytes : container.Iterator[byte] =
    new container.FlatArrayIterator[byte](
      container.FlatArray[byte] !! data,
      length
    );
}