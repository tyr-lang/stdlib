/**
 * A string is a sequence of human readable characters. A string shall behave
 * like an Array[byte] of utf-8-endocding of these characters.
 *
 * @note eq shall be the identity on the bytes in this string
 *
 * @note hashed shall return the xor-folded projection of the bytes in this
 *       string onto hashCode. I.e. if hashCode were 8 bytes long, every 8 bytes
 *       shall be converted to a hashCode and all hashCodes shall be xored.
 */
class String <: Object/* TODO blocker 0.7
                , InheritedHash[String]
                */, abstract {

  /**
   * @return the number of bytes required to represent this string in UTF-8.
   */
  def size : container.size_t;

  /**
   * @return exactly size bytes representing this string as UTF-8 byte sequence.
   *
   * @note if the string is zero-terminated and the zero is considered part of
   *       the string, it has to be taken into account when returning size
   *
   * @note Generally speaking, it is legal to return zero bytes in the middle of
   *       a string. Nonetheless, some subclasses will not be able to do that.
   */
  def bytes : container.Iterator[byte];
}

/**
 * Literal strings that can be evaluated at CT. Be aware of null being a valid
 * StringLiteral!
 */
class StringLiteral <: String, native, noVar {

  def size : container.size_t <: native;

  def bytes : container.size_t <: native;

  /**
   * print the string to std out
   *
   * @note this operator will be removed eventually
   */
  type def !!(v : StringLiteral) : void <: native, operator.postfix, operator.precedence[10];
}
