/**
 * Abstraction of iteration over a container.
 *
 * @note Iterator has currently no map, because the resulting container would
 *       likely result in a memory leak. This statement may no longer be true
 *       when escape-based auto delete is implemented.
 *
 * @note All exhaustive binder calls consume the iterator
 *
 * @author Timm Felden
 */
public class Iterator[T : Type] <: abstract {

  /**
   * retrieve the next element and move the iterator by one element
   *
   * @pre hasNext
   */
  public def next : T;

  /**
   * check if the iterator can provide a next element
   */
  public def hasNext : bool;

  /**
   * Perform action for each remaining element of the iterator and delete the
   * iterator
   *
   * @post !hasNext
   */
  public def foreach (x : BlockParameter[T], action : Block[any]) : void
          <: mem.consumed  {
    while(hasNext()) {
      x = next()
      action.eval()
    }
    delete this
  }

  /**
   * Count the number of elements fulfilling predicate and delete the iterator
   *
   * @post !hasNext
   */
  public def count (x : BlockParameter[T], predicate : Block[bool]) : int
          <: mem.consumed  {
    var r = 0
    while(hasNext()) {
      x = next()
      if(predicate.eval())
        ++r;
    }
    delete this
    return r;
  }

  /**
   * Check predicate until the predicate is false or the iterator is empty
   *
   * @post !result || !hasNext
   *
   * @note does not consume the iterator as it may still be non-empty
   */
  public def forall (x : BlockParameter[T], predicate : Block[bool]) : bool {
    while(hasNext()) {
      x = next()
      if(!predicate.eval())
        return false;
    }
    return true;
  }

  /**
   * Check predicate until the predicate is true or the iterator is empty
   *
   * @post result || !hasNext
   *
   * @note does not consume the iterator as it may still be non-empty
   */
  public def exists (x : BlockParameter[T], predicate : Block[bool]) : bool {
    while(hasNext()) {
      x = next()
      if(predicate.eval())
        return true;
    }
    return false;
  }

  /**
   * fold left on all remaining elements and delete the iterator
   *
   * @post !hasNext
   */
  public def fold (initial : T,
                   left : BlockParameter[T], right : BlockParameter[T],
                   step : Block[T]) : T <: mem.consumed  {
    var r = initial;
    while(hasNext()) {
      left = r;
      right = next();
      r = step.eval();
    }
    delete this
    r
  }

  /**
   * Take all elements from this iterator, add them to an ArrayBuffer and delete
   * the iterator.
   */
  public def toBuffer : ArrayBuffer[T] <: mem.consumed {
    var r = new ArrayBuffer[T]
    while(hasNext()) {
      r += next()
    }
    delete this
    r
  }
}
