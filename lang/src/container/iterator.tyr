/**
 * Abstraction of iteration over a container.
 *
 * @note Iterator has currently no map, because the resulting container would
 *       likely result in a memory leak. This statement may no longer be true
 *       when escape-based auto delete is implemented.
 *
 * @note All exhaustive binder calls consume the iterator
 *
 * @author Timm Felden
 *
 * TODO Iterator should be covariant in T
 */
public class Iterator[T : Type] <: abstract {

  /**
   * retrieve the next element and move the iterator by one element
   *
   * @pre hasNext
   */
  public def next : T;

  /**
   * check if the iterator can provide a next element
   *
   * @note if hasNext has ever returned false, it must not return true for any
   *       subsequent call
   *
   * @note if hasNext has returned true, it must return true for any subsequent
   *       call before the next call to next of the same iterator instance
   */
  public def hasNext : bool;

  /**
   * Perform action for each remaining element of the iterator and delete the
   * iterator
   *
   * @post !hasNext
   */
  public def foreach (x : BlockParameter[T], action : Block[any]) : void
          <: mem.consumed  {
    while(hasNext()) {
      x = next()
      action.eval()
    }
    delete this
  }

  /**
   * Count the number of elements fulfilling predicate and delete the iterator
   *
   * @post !hasNext
   */
  public def count (x : BlockParameter[T], predicate : Block[bool]) : int
          <: mem.consumed  {
    var r = 0
    while(hasNext()) {
      x = next()
      if(predicate.eval())
        ++r;
    }
    delete this
    return r;
  }

  /**
   * Check predicate until the predicate is false or the iterator is empty
   *
   * @post !result || !hasNext
   *
   * @note does not consume the iterator as it may still be non-empty
   */
  public def forall (x : BlockParameter[T], predicate : Block[bool]) : bool {
    while(hasNext()) {
      x = next()
      if(!predicate.eval())
        return false;
    }
    return true;
  }

  /**
   * Check predicate until the predicate is true or the iterator is empty
   *
   * @post result || !hasNext
   *
   * @note does not consume the iterator as it may still be non-empty
   */
  public def exists (x : BlockParameter[T], predicate : Block[bool]) : bool {
    while(hasNext()) {
      x = next()
      if(predicate.eval())
        return true;
    }
    return false;
  }

  /**
   * fold left on all remaining elements and delete the iterator
   *
   * @post !hasNext
   */
  public def fold (initial : T,
                   left : BlockParameter[T], right : BlockParameter[T],
                   step : Block[T]) : T <: mem.consumed  {
    var r = initial;
    while(hasNext()) {
      left = r;
      right = next();
      r = step.eval();
    }
    delete this
    r
  }

  /**
   * Take all elements from this iterator, add them to an ArrayBuffer and delete
   * the iterator.
   */
  public def toBuffer : ArrayBuffer[T] <: mem.consumed {
    var r = new ArrayBuffer[T]
    while(hasNext()) {
      r += next()
    }
    delete this
    r
  }

  /**
   * Wrap this iterator in a buffered iterator owning this.
   *
   * TODO 0.7: return this if this is already a buffered iterator
   */
  public type def buffered(this : Iterator[T]) : BufferedIterator[T]
               <: mem.consumed, inline
                = new BufferedIterator[T](this)

  /**
   * Take another Iterator and create a chained iterator. Ownership of both
   * iterators is transfered to the result.
   */
  public type def ++ (this : Iterator[T], other : Iterator[T]) : Iterator[T]
               <: operator.precedence[110], inline
                = ChainedIterator[T].apply(this, other)
}
