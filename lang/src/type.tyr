/**
 * The type of a type.
 *
 * @note this type is currently used only for typing and has no RT semantics
 *
 * @note if well-typed, Type and Class are, like IntegerLiteral,
 *       recursive and require special treatment by the compiler
 *
 * @note the signature of this type cannot be changed without changing the compiler
 *
 * @todo 0.8 should be sealed
 */
public class Type[+T : Type[any] := any] <: Object, mem.eternal {

  /**
   * Equality on types is a subrelation of equality on pointers, because
   * identical types can exist at most once. Further, it can be decided at
   * compile time for compile-time types.
   *
   * @todo add with CT in 0.7
   */
  // type def == (this : Type, that : Type) : bool
  //            <: CT, native, operator.precedence[80];

  /* create an unelaborated intersection type */
  public type def & (this : Type[_], x : Type[_]) : Type[_]
                    <: reflection.native, inline, operator.precedence[97];
  /* create an unelaborated union type */
  public type def | (this : Type[_], x : Type[_]) : Type[_]
                    <: reflection.native, inline, operator.precedence[93];


  /**
   * static unchecked type casting
   *
   * @note while currently basically any cast is accepted, future versions of
   *       Tyr may restrict this feature to types with similar representation
   */
  public type def !! (this : Type[_], v : any) : this
                     <: reflection.native, operator.precedence[90];
}